[["introduction.html", "Introduction to single-cell RNA-seq data analysis 1 Introduction 1.1 Aims of this course 1.2 Course pre-requisites 1.3 The example data set", " Introduction to single-cell RNA-seq data analysis Eddie Cano-Gamez 2023-05-30 1 Introduction Wellcome to the Introduction to Single-Cell RNA-Sequencing Data Analysis course. My name is Eddie Cano-Gamez, and I am a researcher in immunology and single-cell biology. In this course I aim to help you getting started with analysing single-cell RNA-sequencing (scRNA-seq) data in R. 1.1 Aims of this course In this cousre we will cover basic concepts such as: Which types of files single-cell RNA-seq data are stored in How to load scRNA-seq data into R for analysis How to create suitable R objects to make scRNA-seq data analysis as easy as possbile The basic quality checks which you should perform in any scRNA-seq data set How to visualise cells based on their gene expression profiles We will also briefly touch on a few more advanced concepts like: - Linear and non-linear dimensionality reduction techniques - Unsupervised clustering of cells into cell clusters - Subsequent annotation of cell clusters into cell types based on expression of marker genes Unfortnuately, due to time constrains we will not be able to cover advanced topics, such as: - Trajectory analysis and pseudotime - Multi-omics analysis - Batch integration However, you can always reach me at my institutional email if you have any questions regarding these topics: ecg@well.ox.ac.uk 1.2 Course pre-requisites You do not need to be fluent in R or an expert programming to understand this course. However, some familiarity with R would greatly increase your chances of following the material and learning something new from it. Thus, if you have never programmed in R before, I highly recommend you look at the basic R programming material available in my GitHub before you attend this course: https://eddiecg.github.io/Data-analysis-in-R/introduction-to-programming-in-r.html To follow this course, you will need to install the following: R (version 4 or later): see https://www.r-project.org/ RStudio: see https://posit.co/download/rstudio-desktop/ The R libraries required for this course (see Section 2: Getting Started) NOTE: It’s important you do this before the course, so that you don’t use up other participant’s time in sorting out software installation issues. 1.3 The example data set The practical exercises presented in this course are based on a medium-sized data set of circulating CD4+ T cells obtained from healthy volunteers. This data was generated at the Wellcome Sanger Institute using the 10X scRNA-seq platform and is publicly available. While we won’t be using the full data set (which contains close to 40,000 cells and would be unfeasible to work with in a local laptop), this study has been previously published in Nature Communications (https://doi.org/10.1038/s41467-020-15543-y), and you can access the full data set in the resources associated with that publication. I’ve made this example data set available via my GitHub account, and the following vignettes will show you how to download it. Let’s get going! "],["getting-started.html", "2 Getting started 2.1 Downloading course materials 2.2 Setting up the correct R environment 2.3 Verifying set up", " 2 Getting started Before we get going with data analysis, we will need to make sure that your computing environment is correctly set up and that you have all of the necessary requirements for this course to run smoothly. Let’s review these one by one. 2.1 Downloading course materials We will begin by downloading the example data set used throughout this course. To do so, open your terminal window (i.e. the command line) and run the following command: git clone https://github.com/eddiecg/single-cell-course_2023.git This will clone the GitHub repostiory associated with this course in your local computer, thus automatically downloading all necessary data sets. To make sure all files downloaded successfully, move into the newly created directory by running the following command in the terminal. cd single-cell-course_2023 Finally, run the following in your terminal: ls -l data ## total 38120 ## -rw-r--r--@ 1 eddiecano staff 29797 May 30 13:36 barcodes.tsv.gz ## -rw-r--r--@ 1 eddiecano staff 262330 May 30 13:37 cell-annotations.tsv.gz ## -rw-r--r--@ 1 eddiecano staff 81256 May 30 13:36 features.tsv.gz ## -rw-r--r--@ 1 eddiecano staff 18524082 May 30 13:34 matrix.mtx.gz The output from this command should be a lsit of all the files required for this course. These include: matrix.mtx.gz A single-cell gene expression matrix containing measurements for 20,953 genes across 5,269 cells. barcodes.tsv.gz The cell IDs corresponding to each column of the expression matrix. features.tsv.gz The gene names corresponding to each row of the expression matrix. cell-annotations.tsv.gz A table with annotations and metadata associated with each single cell in the expression matrix. 2.2 Setting up the correct R environment Now that you have downloaded the required data, we can proceed to create an R project specifically for this course and to install the R libraries required for our analysis. Start by opening RStudio and creating an R project. You can do this by selecting: File &gt; New Project Make sure to create the project within the folder you just downloaded (i.e. single-cell-course_2023) Once your project has been created, you can install the required R libraries. You can do this by following one of two options: Using the renv package to automatically install all libraries (recommended): By following these instructions you will be installing the exact same software and library versions that I used to create this course, thus minimising any potential technical issues and differences. Manually installing each library: This is easier to do, but may result in your library versions being slightly different to those I used to create the course. 2.2.1 Option 1: installing all libraries automatically with renv To iuse this option, you will first need to make sure renv is properly installed. You can do so by running the following lines: if (!requireNamespace(&quot;remotes&quot;)) install.packages(&quot;remotes&quot;) remotes::install_github(&quot;rstudio/renv&quot;) Once renv has installed, you can then initialise your R project and automatically install all the rquired libraries, which will by default match the versions I used. You can do so by running the following line: renv::init() renv::restore() NOTE: if asked whether you’d like to restore the project from the existing lockfile, select yes (e.g. 1: Restore the project from the lockfile) 2.2.2 Option 2: installing each library manually Alternatively, if the above method does not work for you, you can also install each library manually using base R. to do so, simply run the following lines: install.packages(&quot;tidyverse&quot;) install.packages(&quot;Seurat&quot;) install.packages(&quot;hexbin&quot;) install.packages(&quot;Matrix&quot;) 2.3 Verifying set up To verify that all libraries were indeed correctly installed, try loading them: library(&quot;tidyverse&quot;) library(&quot;Seurat&quot;) library(&quot;hexbin&quot;) library(&quot;Matrix&quot;) If the code block above ran successfully and without any errors, then you are ready to start this course! "],["practical-studying-cd4-t-cells-from-human-blood.html", "3 Practical: Studying CD4+ T cells from human blood 3.1 Overview 3.2 Loading data and R libraries 3.3 Formatting data for analysis 3.4 Removing low quality cells and genes 3.5 Analysing gene expression data 3.6 Data visualisation 3.7 Clustering cells into groups 3.8 Identifying cell type markers 3.9 Conclusion 3.10 R session", " 3 Practical: Studying CD4+ T cells from human blood Now that you have downloaded the necessary data and installed any pre-required libraries, we can begin our analysis. 3.1 Overview In this course, we will analyse a data set of CD4+ T cells in circulating blood obtained from four healthy volunteers. This data comes from a study published in 2020 by myself and colleagues, and titled Single-cell transcriptomics identifies an effectorness gradient shaping the response of CD4+ T cells to cytokines. For this study, we drew blood from healthy research participants and used a combination of laboratory techniques to isolate naive and memory CD4+ T cells from these blood samples. CD4+ T cells are one of the main participants in the immune response: they protect us against pathogens by telling the rest of the immune system what to do. However, we do not yet fully understand just how diverse these cells are and how much they can adapt to the environment in which they are present. That’s what our study tried to find out. The experimental design of our study is summarised in the following diagram: Experimental design: we isolated naive and memory CD4 possitive T cells from four healthy volunteers and profiled them at several points in time While our study sequenced more than 40,000 cells, that scale of data would be difficult to deal with in a regular laptop without taking up most of your computer memory. Thus, I have prepared a smaller subset of that data set, which will limit our analysis for this course to only one of the conditions we studied: cells obtained directly from blood and sequenced without any further treatment. This is what’s contained in the example data set you downloaded from GitHub. 3.2 Loading data and R libraries To begin with, let’s load the following R libraries: library(tidyverse) library(Seurat) library(hexbin) Next, let’s load the data you downloaded from GitHub into R. We do this by using the Read10X function in the Seurat library. Note how this function goes to the loaction you are pointing it to and finds three files: the expression table itself (matrix.mtx), the gene names (features.tsv), and the cell names (barcodes.tsv). Next, it reads all three files into RAM and combines them together. t_cell_data &lt;- pbmc.data &lt;- Read10X(data.dir = &quot;./data/&quot;, gene.column=1) We will also read into memory the cell-annotations.tsv file, which contains information for each cell, based on the observations we published in our study. cell_anns &lt;- read.table(file = &quot;./data/cell-annotations.tsv.gz&quot;, sep=&quot;\\t&quot;) 3.3 Formatting data for analysis 3.3.1 Creating a Seurat object While our data has been loaded into R successfully, it is still not in the most convenient format for us to analyse. Thus, we will use it to create a so called “Seurat Object”. This object is a data structure specifically designed for single-cell data analysis, and which will make our lives easier down the line. You can create a Seurat Object by running the following line: t_cells &lt;- CreateSeuratObject( counts = t_cell_data, project = &quot;CD4_T_cells&quot;, min.cells = 3, min.features = 200 ) The resulting object looks as follows: t_cells ## An object of class Seurat ## 14835 features across 5269 samples within 1 assay ## Active assay: RNA (14835 features, 0 variable features) Note how R is telling us that our Seurat object contains information for 14,835 features (i.e. genes) and 5,269 samples (i.e. cells). This means that this little object contains more than 78 million numbers! This is not untypical of single-cell experiments, which are one of the technologies capable of generating the most amount of data these days. So how is it possible to work with more than 78 million numbers without making our computer crash completely? 3.3.2 How are single-cell measurements actually handled by the computer? Partly, this is due to a very clever computational trick. Let’s look at the first 10 rows and the first 10 columns of our data set: pbmc.data[1:10, 1:10] ## 10 x 10 sparse Matrix of class &quot;dgCMatrix&quot; ## ## RP11-34P13.7 . . . . . . . . . . ## FO538757.2 1 . . . . 1 . . 1 1 ## AP006222.2 . . . . . . . . . . ## RP4-669L17.10 . . . . . . . . . . ## RP11-206L10.9 . . . . . . . . . . ## LINC00115 . . . . . . . . . . ## FAM41C . . . . . . . . . . ## NOC2L . . . . . . 1 . . 1 ## KLHL17 . . . . . . . . . . ## PLEKHN1 . . . . . . . . . . Let’s take some time to understand what is going on here. This is an expression matrix. Each column represents one cell, and each row represents one gene. The numbers in the matrixtell us how many molecules (which is proportional to the number of mRNAs) of each gene were detected in each cell. You’ll notice a large number of dots (.). These dots represent zeros. The majority of the data generated by a single-cell experiment is made up of zeros: genes that were either not expressed in that cell or could not be detected due to them being present at a very low amount. We call this phenomenon (too many zeros) sparsity. In order to save memory and make our analysis run much faster, Seurat does not store zeros in memory at all: they simply are left empty with a placeholder (represented here by the dot). If we wanted to, we could transform these dots into actual zeros, with the following line: as.matrix(pbmc.data[1:10, 1:10]) ## N_resting_AAACCTGAGCTGTCTA N_resting_AAACCTGTCACCACCT N_resting_AAACCTGTCCGTTGTC N_resting_AAACGGGAGGGTTCCC N_resting_AAACGGGCAACAACCT ## RP11-34P13.7 0 0 0 0 0 ## FO538757.2 1 0 0 0 0 ## AP006222.2 0 0 0 0 0 ## RP4-669L17.10 0 0 0 0 0 ## RP11-206L10.9 0 0 0 0 0 ## LINC00115 0 0 0 0 0 ## FAM41C 0 0 0 0 0 ## NOC2L 0 0 0 0 0 ## KLHL17 0 0 0 0 0 ## PLEKHN1 0 0 0 0 0 ## N_resting_AAACGGGCACAACGCC N_resting_AAACGGGGTGCCTGTG N_resting_AAAGATGCACGGCCAT N_resting_AAAGATGCATCGATTG N_resting_AAAGCAAAGCGTGAAC ## RP11-34P13.7 0 0 0 0 0 ## FO538757.2 1 0 0 1 1 ## AP006222.2 0 0 0 0 0 ## RP4-669L17.10 0 0 0 0 0 ## RP11-206L10.9 0 0 0 0 0 ## LINC00115 0 0 0 0 0 ## FAM41C 0 0 0 0 0 ## NOC2L 0 1 0 0 1 ## KLHL17 0 0 0 0 0 ## PLEKHN1 0 0 0 0 0 However, if we measure the amount of memory taken up by the matrix when zeros are not stored versus when they are, we will notice the following: format(object.size(pbmc.data), units=&quot;Mb&quot;) ## [1] &quot;70.8 Mb&quot; format(object.size(as.matrix(pbmc.data)), units=&quot;Mb&quot;) ## [1] &quot;844.1 Mb&quot; Storing zeros as numbers would make our matrix 12 times bigger! That is why they are left empty instead. It’s just more convenient. 3.3.3 Adding cell annotations to our matrix Let’s now move on to the cell annotations table. Printing the first few lines of this table reveals the type of information stored in it: head(cell_anns) ## cell.type cytokine.condition donor.id batch.10X nGene nUMI percent.mito S.Score G2M.Score Phase cluster.id ## N_resting_AAACCTGAGCTGTCTA Naive UNS D4 2 1163 4172 0.02349556 -0.13419873 -0.1592109 G1 TN (resting) ## N_resting_AAACCTGTCACCACCT Naive UNS D4 2 1037 3690 0.02086721 -0.10175611 -0.2037066 G1 TN (resting) ## N_resting_AAACCTGTCCGTTGTC Naive UNS D2 2 1245 4446 0.02790279 -0.14513081 -0.1642104 G1 TN (resting) ## N_resting_AAACGGGAGGGTTCCC Naive UNS D4 2 1016 3913 0.01150895 -0.06949151 -0.1908101 G1 TN (resting) ## N_resting_AAACGGGCAACAACCT Naive UNS D1 2 1005 3557 0.03964015 -0.12400660 -0.1433789 G1 TN (resting) ## N_resting_AAACGGGCACAACGCC Naive UNS D2 2 1404 5758 0.03179291 -0.18880479 -0.1985836 G1 TN (resting) ## effectorness ## N_resting_AAACCTGAGCTGTCTA 0.15181238 ## N_resting_AAACCTGTCACCACCT 0.03176291 ## N_resting_AAACCTGTCCGTTGTC 0.11389687 ## N_resting_AAACGGGAGGGTTCCC 0.34123968 ## N_resting_AAACGGGCAACAACCT 0.01974084 ## N_resting_AAACGGGCACAACGCC 0.12576722 Amongst the information contained here are: the name (or ID) of each cell, the cell type it belongs to, the individual it was isolated from, the number of genes that were detected inside this cell, etc… All of these variables come from our published study and are only kept here as a reference for comparisons. Let’s add this information as metadata into our Seurat Object: t_cells@meta.data &lt;- cbind(t_cells@meta.data, cell_anns) 3.4 Removing low quality cells and genes We now have our data in the right format for analysis. However, we are not quite ready for analysing the biology of this dat set yet. Instead, we first need to remove any technical errors or biases which may skew our conclusions. 3.4.1 Cell filtering There are many sources of bias and technical error in a single cell experiment, but two of them stand out: - Apoptotic/dying cells (which could skew our observatoins) - Multiplets: instances where two or three cells stuck together during the experiment, so that they now seem to be a single cell but really they are two or more cells. We can remove some of these biases by performing quality filtering. We will being by removing potentially dying/apoptotic cells. When cells have lysed or are dying, their cell membrane is compromised and pores start appearing along its surface. This causes mRNA molecules to leak outside the cell. However, the mRNAs contained in the mitochondria will not leak as easily, because they have to traverse two sets of membranes: the mitochondrial and the cell membrane. Thus they tend to be retained inside the cell more easily, even when a cell has died. We can measure this phenomenon by calculating the “mitochondrial proportion”. That is, by estimating what percentage of the molecules detected in a cell come from mitochondrial genes (which are physically located inside the mitochondria). The Seurat package has a function which does this for us automatically: t_cells[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(t_cells, pattern = &quot;^MT-&quot;) The pattern “^MT-” which we specified tells R that any genes whose name starts with MT- should be counted as mitochondrial genes. Now that we have estimated this metric. Let’s visualise it. The following code generates a graph where we can see how many genes were detected as expressed in each cell (X axis), as well as the proportion of molecules which come from the mitochondria (Y axis). The lighter the colour, the more cells are located in that area of the graph, and vice versa. ggplot(t_cells@meta.data, aes(x=nFeature_RNA, y=percent.mt)) + geom_hex(bins=70) + geom_hline(yintercept = 5, linetype=&quot;dotted&quot;) + geom_vline(xintercept = 1600, linetype=&quot;dotted&quot;) + xlab(&quot;Number of genes per cell&quot;) + ylab(&quot;Proportion of reads in mitchondrial genes (%)&quot;) + theme_bw() + theme(panel.grid = element_blank()) You’ll notice that the majority of cells have around 1500 genes detected, and only about 2.5% of molecules coming from the mitochondria. However, there are some exceptions: Cells above the horizontal line have too many mitochondrial mRNAs. This means that they may be apoptotic Cells to the right of the vertical line have too many genes detected. This means they may be multiplets (i.e. two cells stuch together rather than one) Thus, we use the following line to remove any cells that have either more than 5% of mitochondrial molecules (likely apoptotic) or more than 1600 genes detected (likely multiplets): t_cells &lt;- subset(t_cells, subset = nFeature_RNA &lt;= 1600 &amp; percent.mt &lt;= 5) This should significantly clean our data set and remove potential confounding factors. 3.4.2 Gene filtering We now turn our attention to the genes. We have over 14,000 genes, but it’s likely that many of them are present at very low levels or even not present at all. The following line takes each gene in our matrix and counts in how many cells it is present (i.e. it is not zero). cells_expressing_gene &lt;- rowSums(GetAssayData(t_cells) &gt; 0) If we visualise these counts, we’ll notice that a lot of genes are not detected in any cell at all. These are simply taking up unnecessary space in our computer: hist(cells_expressing_gene, breaks = 150, xlab=&quot;Number of cells expressing the gene&quot;, main=&quot;Gene expression distribution&quot;) The following line removes any genes that are simply not found in any cell in the study: t_cells &lt;- subset(t_cells, features = rownames(t_cells)[cells_expressing_gene &gt; 0]) After filtering out both low quality cells and low quality genes, we are left with 4,979 cells and 14,832 genes: t_cells ## An object of class Seurat ## 14832 features across 4979 samples within 1 assay ## Active assay: RNA (14832 features, 0 variable features) 3.5 Analysing gene expression data Having done a stringent quality check, we are now ready to start analysing our data. We being by performing normalisation and data transformation steps. These have the following aims: - Normalisation: to correct for gross differences in the depth of sequencing between samples. For example, maybe cells sequenced in the first experiment have a lot more molecules than cells sequenced in the second experiment (due to differences in how the sequencer ran). This difference would need to be removed. - Log-transformation: While some genes have 1 or 2 molecules, others will have 100s of molecules detected. This is a very wide range, and it makes our data have a very skewed distribution. Thus, we apply a logarithm operation, which makes the data nicely centered around a mean value (similarly to a normal distribution). Both of these operations are performed by the following Seurat function: t_cells &lt;- NormalizeData(t_cells) Next, we identify which genes tend to vary the most from one cell to another. These tend to be the most interesting genes. If a gene is present at exactly the same level in every cell, then it’s not very interesting. If, instead, it is present at very high levels in one type of cell but at minimnal levels in another one, it could be a very interesting gene with a specific function in the cell type where it is present. The following function ranks genes according to how much they tend to vary and identifies the top variable (often termed highly variable genes of HVGs. In this case we will get 2,000 of them). t_cells &lt;- FindVariableFeatures(t_cells, selection.method = &quot;vst&quot;, nfeatures = 2000) Out of curiosity, what are these genes? The following code generates a simple visualisation telling us how high the level of each gene is on average (X axis) and how much it tends to vary between cells (Y axis). # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(t_cells), 10) # plot variable features with and without labels plot1 &lt;- VariableFeaturePlot(t_cells) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) plot2 The most variable genes here are chemokines (CCL5), granulysins (GNLY) and other genes known to distinguish very specific types of T cells. This is encouraging: we are on the right path. Finally, we scale the data in our expression matrix. This will make the rest of the analysis easier. t_cells &lt;- ScaleData(t_cells, features = rownames(t_cells)) 3.6 Data visualisation Our pre-processing is now over! Let’s explore some interesting biology. At the moment we have thousands of variables measured across thousands of cells. How do we even begin to make sense of so much information? One common approach is dimensionality reduction, which is based on discarding the majority of these thousands of measurements and instead looking at a combination of those genes which are most informative. Dimensionality reduction is a complex field of mathematical research, and thus a detailed explanation falls outside of the scope of this course. However, its aim is simple: summarising those thousands of genes (called here dimensions) into a handful of useful variable. To do this, we use a combination of linear and non-linear techniques. 3.6.1 Principal component analysis (PCA) We begin with a linear technique called principal component analysis (PCA). This technique is based on linear algebra and rotations around our feature space which identify a small set of gene combinations that summarise most of the information contained in our data set. These gene combinations are called “principal components” or PCs. The following line performs PCA on our single-cell expression data: t_cells &lt;- RunPCA(t_cells, features = VariableFeatures(object = t_cells)) The line above generated a list of principal components. But how many of these are useful? Let’s assess how much information each of them contains: ElbowPlot(t_cells) Note how the variable in the Y axis, which reflects the amount of new information contained by each component (X axis), slowly gets smaller and smaller. In fact, anything beyond the 10-th component is pretty much negligible. So 10 components are enough to summarise the majority of the information in our data set. We have gone from 1000s of genes to 10 components. 3.6.2 Component embedding with UMAP While 10 variables is better than 1000s of them, it is still a lot. Thus, we will take those 10 components and “embed” them into a 2-dimensional plot. We do this by using a technique called UMAP, which relies on bending our features space and identifying manifolds within it that could better explain our data structure. This may sound quite abstract, but the results are very easily intepretable and informative. Let’s have a look. The code block below takes the first 10 components we just calculated and embeds them with UMAP. set.seed(1) t_cells &lt;- RunUMAP(t_cells, dims = 1:10) But what does this even mean? Well, let’s see for ourselves what the result looks like: DimPlot(t_cells, reduction = &quot;umap&quot;) The graph above is the result from our PCA + UMAP attempt to reduce dimensions. In this graph, each dot represents a cell. The position of each cell in this plot is determined by a complex combination of the thousands of variables we measured. This can be interperted as follows: If two dots are close to each other, then it means that the two cells have very similar gene expression patterns If two dots are very far away, then that means the two cells are entirely different frome each other In the plot above, red and blue indicates which cells are memory T cells and which are naive T cells. In our published study, we did a lot of analysis to understand which T cells belonged to different cell subsets, and that information is included in our metadata table. Thus, let’s now re-do the graph above but colouring cells by their cell type identity: DimPlot(t_cells, reduction = &quot;umap&quot;, group.by = &quot;cluster.id&quot;) Note how naive cells are on one side of the plot, while memory cells are on the other. Within memory cells, central and effector memory cells separate from each other, and regulatory T cells (which have a completely different cell function and biology) also segregate into their own smaller group. Seurat also allows us to visualise how active each of the thousands of genes in our matrix is in each cell. The code block below does this for four example genes: - SELL: Selectin, known to be expressed by naive T cells - KLRB1: Known to be expressed by effector memory T cells - PRF1: Marker of T cells with cytotoxic capacity - IL1R2A: Molecule needed by regulatory T cells to survive FeaturePlot(t_cells, reduction = &quot;umap&quot;, features = &quot;SELL&quot;) FeaturePlot(t_cells, reduction = &quot;umap&quot;, features = &quot;KLRB1&quot;) FeaturePlot(t_cells, reduction = &quot;umap&quot;, features = &quot;PRF1&quot;) FeaturePlot(t_cells, reduction = &quot;umap&quot;, features = &quot;IL2RA&quot;) Indeed, each of these genes is detected in the cell type where we would expect it to be. 3.7 Clustering cells into groups For this example, I provided you with pre-existing cell annotations which tell us which cell belongs to which group. But what if you don’t know that? That’s what happens in most real life applications where we use single-cell techniques. If we don’t know how many cell types or subtypes we are expecting or how they look like, we can proceed to do a so-called “unsupervised” grouping or clustering of cells. This means that, rather than starting with a pre-conceived assumption about what our cells should look like, we simply compare them to one another and identify patterns. If a group of cells looks remarkably similar to each other, then we group them together. The Seurat library provides a few functions that we can use to do this. These functions create a “graph” by connecting together cells which are similar to each other, and then identify groups or communities of similar cells, since they are very interconnected in the graph. The following lines perform unsupervised cell clustering at a high level resolution: set.seed(1) t_cells &lt;- FindNeighbors(t_cells, dims = 1:10) t_cells &lt;- FindClusters(t_cells, resolution = 0.3) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 4979 ## Number of edges: 157220 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8535 ## Number of communities: 5 ## Elapsed time: 0 seconds Let’s now look at the results from our unsupervised cell grouping: DimPlot(t_cells, reduction = &quot;umap&quot;) Perhaps unsurprisingly, the groups identified using these algorithm correspond almost exactly with the annotations I provided you with. 3.8 Identifying cell type markers Now that we have grouped cells by similarity, how can we learn more about their biology and understand what each group means? To do so, we take each gene in our expression table and compare its level between different cell groups: does it tend to be expressed at a significantly higher or lower level in one cell group compared to the remaining ones? That is what the following function tests (note that this may take a little while to run. After all, this function is doing thousands of tests): t_cell_markers &lt;- FindAllMarkers(t_cells, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) The result of running the line of code above is a list of all genes which are significantly higher or lower in one cell group compared to the others. This looks as follows: t_cell_markers %&gt;% group_by(cluster) %&gt;% slice_max(n = 2, order_by = avg_log2FC) ## # A tibble: 10 × 7 ## # Groups: cluster [5] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.89e-155 0.941 0.375 0.071 5.76e-151 0 LRRN3 ## 2 2.17e-119 0.804 0.64 0.333 3.22e-115 0 CCR7 ## 3 4.91e- 72 0.844 0.499 0.268 7.28e- 68 1 PASK ## 4 8.68e-125 0.813 0.531 0.197 1.29e-120 1 ITGB1 ## 5 1.04e-274 2.62 0.721 0.118 1.54e-270 2 CCL5 ## 6 1.84e-184 1.57 0.633 0.14 2.73e-180 2 LYAR ## 7 2.86e-113 2.21 0.689 0.152 4.25e-109 3 LGALS1 ## 8 1.10e- 83 1.91 0.956 0.602 1.63e- 79 3 S100A4 ## 9 0 3.77 0.833 0.007 0 4 NKG7 ## 10 0 3.54 0.63 0.007 0 4 GNLY Note how R has calculated the average expression of that gene, as well as performed statistical testing to check if the gene is higher in any one group of cells. This is what the p values represent. We can understand this information better by looking at it visually using a technique called a heatmap: top_markers &lt;- t_cell_markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) DoHeatmap(t_cells, features = top_markers$gene) + NoLegend() In this graph, each row is a gene and each (very thin) column is a cell. Black means the gene is not detected in that cell, and bright yellow means it is detected at a high level. Cells have been automatically grouped by similarity and divided into the four populations we identified using unsupervised clustering. Note how some populations (for example cluster 4) have a very clear signature of genes (in this case, genes which are all involved in cytotoxic capacity). 3.9 Conclusion In this course, we used a medium-sized data set of human CD4+ T cells to understand some of the fundamental concepts in single-cell RNA-seq data analysis. We also gained hands on experience on how to analyse this data, including pre-processing, quality checks, visualisation, and unsupervised grouping of cells by similarity. I hope you found this course useful. 3.10 R session sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: aarch64-apple-darwin20 (64-bit) ## Running under: macOS Big Sur 11.5.2 ## ## Matrix products: default ## LAPACK: /Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices datasets utils methods base ## ## other attached packages: ## [1] Matrix_1.5-4.1 hexbin_1.28.2 SeuratObject_4.1.3 Seurat_4.3.0 forcats_0.5.1 stringr_1.5.0 dplyr_1.1.2 ## [8] purrr_1.0.1 readr_2.1.2 tidyr_1.3.0 tibble_3.2.1 ggplot2_3.4.2 tidyverse_1.3.2 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.3.1 backports_1.4.1 plyr_1.8.8 igraph_1.4.3 lazyeval_0.2.2 sp_1.6-0 ## [7] splines_4.1.0 listenv_0.9.0 scattermore_1.1 digest_0.6.31 htmltools_0.5.5 fansi_1.0.4 ## [13] magrittr_2.0.3 tensor_1.5 googlesheets4_1.0.0 cluster_2.1.4 ROCR_1.0-11 tzdb_0.2.0 ## [19] globals_0.16.2 modelr_0.1.8 matrixStats_0.63.0 spatstat.sparse_3.0-1 colorspace_2.1-0 rvest_1.0.2 ## [25] ggrepel_0.9.3 haven_2.4.3 xfun_0.39 crayon_1.5.2 jsonlite_1.8.4 progressr_0.13.0 ## [31] spatstat.data_3.0-1 survival_3.5-5 zoo_1.8-12 glue_1.6.2 polyclip_1.10-4 gtable_0.3.3 ## [37] gargle_1.2.0 leiden_0.4.3 future.apply_1.11.0 abind_1.4-5 scales_1.2.1 DBI_1.1.2 ## [43] spatstat.random_3.1-5 miniUI_0.1.1.1 Rcpp_1.0.10 viridisLite_0.4.2 xtable_1.8-4 reticulate_1.28 ## [49] htmlwidgets_1.6.2 httr_1.4.6 RColorBrewer_1.1-3 ellipsis_0.3.2 ica_1.0-3 pkgconfig_2.0.3 ## [55] farver_2.1.1 sass_0.4.6 uwot_0.1.14 dbplyr_2.1.1 deldir_1.0-9 utf8_1.2.3 ## [61] tidyselect_1.2.0 labeling_0.4.2 rlang_1.1.1 reshape2_1.4.4 later_1.3.1 cachem_1.0.8 ## [67] munsell_0.5.0 cellranger_1.1.0 tools_4.1.0 cli_3.6.1 generics_0.1.3 broom_0.7.12 ## [73] ggridges_0.5.4 evaluate_0.21 fastmap_1.1.1 yaml_2.3.7 goftest_1.2-3 knitr_1.43 ## [79] fs_1.6.2 fitdistrplus_1.1-11 RANN_2.6.1 pbapply_1.7-0 future_1.32.0 nlme_3.1-162 ## [85] mime_0.12 xml2_1.3.3 compiler_4.1.0 rstudioapi_0.13 plotly_4.10.1 png_0.1-8 ## [91] spatstat.utils_3.0-3 reprex_2.0.1 bslib_0.4.2 stringi_1.7.12 highr_0.10 lattice_0.21-8 ## [97] vctrs_0.6.2 pillar_1.9.0 lifecycle_1.0.3 jquerylib_0.1.4 spatstat.geom_3.2-1 lmtest_0.9-40 ## [103] RcppAnnoy_0.0.20 data.table_1.14.8 cowplot_1.1.1 irlba_2.3.5.1 httpuv_1.6.11 patchwork_1.1.2 ## [109] R6_2.5.1 bookdown_0.34 promises_1.2.0.1 renv_0.17.3-74 KernSmooth_2.23-21 gridExtra_2.3 ## [115] parallelly_1.36.0 codetools_0.2-19 MASS_7.3-60 assertthat_0.2.1 withr_2.5.0 sctransform_0.3.5 ## [121] parallel_4.1.0 hms_1.1.1 grid_4.1.0 rmarkdown_2.21 googledrive_2.0.0 Rtsne_0.16 ## [127] spatstat.explore_3.2-1 shiny_1.7.4 lubridate_1.8.0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
